# 10월 15일 TIL

* ### 알고리즘

    * [시소 짝궁](https://school.programmers.co.kr/learn/courses/30/lessons/152996)
    
      <details>
      <summary><strong>코드 - 비둘기 집 원리(42분)</strong></summary>

        ```java

            import java.util.*;

            class Solution {
                public long solution(int[] weights) {
                    long answer = 0;
                    Map<Integer, Long> ori = new HashMap<>();
                    
                    boolean[][] visit = new boolean[1001][1001];
                    for(int weight : weights){
                        ori.put(weight, ori.getOrDefault(weight, 0L) + 1);
                    }
                    
                    for(int o1 : ori.keySet()){
                        answer += (ori.get(o1) * (ori.get(o1) - 1)) / 2;
                        visit[o1][o1] = true;
                        
                        for(int o2 : ori.keySet()){
                            if(visit[o1][o2])
                                continue;
                            
                            if(canRide(o1, o2)){
                                answer += ori.get(o1) * ori.get(o2);
                            }
                            
                            visit[o1][o2] = visit[o2][o1] = true;
                        }
                    }
                    
                    return answer;
                }
                
                private boolean canRide(int o1, int o2){
                    for(int i=2 ; i<=4 ; i++){
                        for(int j=2 ; j<=4 ; j++){
                            if(o1 * i == o2 * j){
                                return true;
                            }
                        }
                    }
                    
                    return false;
                }
            }


      ```

    </details>

* ### 공부한 내용

    <details>
    <summary><strong>POJO</strong></summary>

    * <h3>POJO란?</h3>
    
      * POJO(Plain Old Java Object)는 순수한 자바라는 뜻으로 Java로 생성하는 순수한 객체이다. <br/> 따라서, 자바를 사용하는 어떠한 환경 혹은 어떠한 기술에서도 사용할 수 있는 객체이다.
      
      * 클래스의 순수 메소드나 필드, setter, getter 등이 POJO이다.
  
    * <h3>POJO와 객체지향 관계</h3>
    
      * <strong>캡슐화</strong>: POJO인 setter, getter를 사용하여 객체지향의 특징인 캡슐화를 가능하게 한다.
      
      * <strong>DI</strong>: 특정 프레임워크에 종속되지 않기 때문에 객체 간의 의존성을 자유롭게 주입할 수 있다.

      * <strong>SRP</strong>: 각 객체는 자신만의 책임을 가지고 있어서 특정 역할에 집중되도록 설계가 가능하다.

    * <h3>POJO는 어떤 이점을 가지는가</h3>
    
      * 1. 특정 환경이나 기술에 종속적이지 않고 재사용이 가능하며 유지 보수 및 확장 가능한 코드를 작성할 수 있게 한다.
      
      * 2. 비즈니스 로직과 특정 환경 종속적인 코드를 분리하기 때문에 코드가 단순해진다.
      
      * 3. 특정 환경에 종속적인 로직이 포함된 객체는 테스트가 어렵지만, POJO는 테스트가 단순하다.

      * 4. 객체지향적인 설계를 제한없이 적용할 수 있다.

    </details>

    <details>
    <summary><strong>디자인 패턴</strong></summary>

    * 디자인 패턴은 개발하면서 반복적으로 발생하는 문제들을 해결하기 위한 방안이다. <br/> 실제 협업에서 비즈니스 요구 사항을 프로그래밍으로 처리하면서 만들어진 다양한 해결책 중 많은 사람들이 인정한 모범 사례이다.

    * <h3>싱글톤 패턴</h3>
  
      * 특정 클래스에 객체 인스턴스가 하나만 만들도록 해주는 패턴이다. 싱글톤 패턴을 사용하면 전역 변수처럼 모든 객체 인스턴스에서 접근할 수 있게 해준다. 그래서, 동시성 문제 등 고려하면서 설계하고 사용해야 한다.

      * <strong>장점</strong>
      
        * 1. 메모리 측면: 하나의 인스턴스만 생성하여 사용하기 때문에 메모리 낭비를 줄일 수 있다.
      
        * 2. 속도 측면: 이미 생성된 인스턴스를 사용하기 때문에 추가적인 시간이 필요없다.

        * 3. 데이터 공유가 용이: 전역으로 사용하는 인스턴스이기 때문에 여러 클래스에서 데이터를 공유하며 사용할 수 있다.

      ``` java

          public class Singleton {
              public class Singleton {
                  private static Singleton instance;

                  // 아무곳에서 생성되지 않도록 private로 설정
                  private Singleton() {}
                  
                  // 멀티 스레드 환경에서 여러개가 만들어지지 않도록 synchronized를 이용해서 동기화 처리
                  public static synchronzied Singleton getInstance() {
                      if(instance  == null) {
                          instance  = new Singleton();
                      }
                      return instance;
                  }
              }
          }

      ```

    * <h3>프록시 패턴</h3>

        * 프록시는 대리자, 대변인이라는 의미를 가지고 있으며, 어떠한 객체 대신 작업을 수행하는 프록시 객체를 만드는 패턴이다.

        * <strong>장점</strong>

            * 1. 접근 제어: 실제 객체에 접근하지 않고 실제 객체의 접근을 관리하고 권한 검사 등을 수행할 수 있다.
            
            * 2. 지연 초기화: 실제 객체의 생성 및 초기화를 지연시켜 필요한 순간에만 생성 및 초기화함으로써 최적화할 수 있다.

            * 3. 캐싱: 결과를 캐싱하여 성능을 향상할 수 있다.

            * 4. 유효성 검사: 실제 객체에 접근하기 전에 유효성 검사를 할 수 있다.

            * 5. 원격 접근: 원격 프록시를 이용하면 다른 시스템에서 실행 중인 객체에 접근할 수 있다.

        * <strong>단점</strong>

            * 1. 복잡성 증가: 추가적인 객체를 사용하기 때문에 코드의 복잡성이 증가한다.
            
            * 2. 성능 저하: 프록시 객체에 접근하는 것에 추가적인 오버헤드가 발생할 수 있다.

            * 3. 디자인 복잡성: 패턴을 잘못 사용하면 과도하게 복잡해진다.

        > <strong>AOP</strong>: Spring의 AOP는 프록시 패턴을 사용해서 동작한다. 실제 객체의 실행 전후에 부가적인 로직을 수행함으로써 비즈니스 로직과 분리 시킬 수 있다.

    * <h3>데코레이터 패턴</h3>

        * 데코레이터 패턴은 대상 객체에 대한 기능 확장이나 변경이 필요할 때 객체의 결합을 통해 서브클래싱 대신 사용할 수 있는 유연한 대안 구조 패턴이다.

        * <strong>장점</strong>
            
            * 1. 결합: 객체를 여러 데코레이터로 Wrapping해서 여러 동작을 결합시킬 수 있다.

            * 2. 동적: 컴파일 타임이 아닌 런타임에 동적으로 기능을 변경할 수 있다.

            * 3. SRP: 각 장식자 클래스마다 고유의 책임을 가진다.

            * 4. OCP: 클라이언트 코드 수정없이 기능 확장이 가능하다.

            * 5. DIP: 구현체가 아닌 인터페이스를 바라보기 때문에 DIP를 준수한다.

        * <strong>단점</strong>

            * 1. Wrapper 제거: 데코레이터를 조합한 Wrapper 스택에서 특정 데코레이터를 제거하기 쉽지 않다.
            
            * 2. 지저분함: 데코레이터를 조합하는 코드가 지저분할 수 있다. (ex new A(new B(new C())))

        > :bulb: <strong>프록시와의 차이점은?</strong> <br/>
        > 프록시 패턴은 Wrapper 클래스와 실제 객체는 컴파일 타임에서 결정나고 실제 객체의 접근에 대한 제어를 목적으로 하고 있다.
        > 반면에, 데코레이터 패턴은 런타임에 Wrapper 클래스와 실제 객체의 관계를 런타임에 결정하고 실제 객체의 기능에 다른 기능을 추가하는 목적으로 사용한다.


    * <h3>탬플릿 메소드 패턴</h3>

        * 탬플릿 메소드 패턴은 여러 클래스에서 공통으로 사용하는 메소드를 탬플릿화하여 상위 클래스에서 정의하고, 하위 클래스마다 세부 동작 사항을 다르게 구현하는 패턴이다.
        
        * <strong>장점</strong>

            * 1. 영향력 감소: 클라이언트가 특정 부분만 재정의하도록 해서 다른 부분에 발생하는 변경 사항의 영향을 덜 받도록 한다.
            
            * 2. 중복 제거: 추상클래스로 로직을 공통화하면서 코드의 중복을 줄인다.

            * 3. 서브 클래스 역할 감소: 핵심 로직을 상위 클래스에서 관리함으로써 관리가 용이해진다.

        * <strong>단점</strong>

            * 1. 유연성 감소: 제공된 골격에 의해 유연성이 제한될 수 있다.
            
            * 2. 유지: 로직이 복잡할수록 로직 형태를 유지하기 어려워진다.
        
            * 3. 관리: 추상 메소드가 많아지면 생성, 관리가 어려워질 수 있다.
            
            * 4. 고려: 상위 클래스에서 선언된 추상 메소드를 하위 클래스에서 구현할 때, 그 메소드가 어느 타이밍에서 호출되는지 클래스 로직을 이해해야 한다.

            * 5. 수정 어려움: 상위 클래스를 수정하면, 모든 서브 클래스의 수정이 필요할 수 있다.
            
            * 6. LSP 위반: 하위 클래스를 통해 기본 단계 구현을 억제하여 LSP를 위반할 수 있다.

    * <h3>팩토리 메소드 패턴</h3>

        * 팩토리 메소드 패턴은 객체 생성을 공장 클래스로 캡슐화 처리해서 대신 생성하게 하는 생성 디자인 패턴이다.

        * <strong>장점</strong>
            
            * 1. 약한 결합: 생성자와 구현 객체의 강한 결합을 줄일 수 있다.

            * 2. 공통 로직: 객체의 생성 후 공통으로 수행되는 일을 지정할 수 있다.

            * 3. 은닉성 증가: 캡술화, 추상화를 통해 생성되는 객체의 구체적인 타입을 감출 수 있다.

            * 4. OCP: 기존 코드를 수정하지 않고 새로운 유형의 제품 인스턴스를 프로그램에 도입할 수 있다.

            * 5. SRP: 객체 생성 코드를 한 클래스에서 하기 때문에 유짖보수하기 쉽다.

        * <strong>단점</strong>

            * 1. 과도한 클래스 증가: 각 제품 구현체마다 팩토리 객체들을 모두 구현해야 하기 때문에, 구현체가 늘어날 때마다 팩토리 클래스도 같이 늘어나서 클래스 수가 과도하게 증가할 수 있다.
            
            * 2. 복잡성 증가: 코드의 복잡성이 증가한다.

    * <h3>전략 패턴</h3>

        * 전략 패턴은 런타임중에 알맞은 전략을 선택하여 객체 동작을 실시간으로 변경하도록 해주는 행위 디자인 패턴이다.

        * <strong>장점</strong>
            
            * 1. 동적 할당: 캡슐화하여 런타임에 적절한 전략을 선택해서 사용한다.

            * 2. 유연성 증가: 쉽게 변경 및 대체할 수 있기 때문에 유연해진다.

            * 3. 확장성 증가: 추가 및 수정을 할 때 코드 수정이 최소화되기 때문에 확장성이 높아진다.

            * 4. 재사용성 증가: 캡슐화를 했기 때문에 재사용성이 증가한다.

            * 5. 테스트 용이성: 각 전략을 독립적으로 테스트를 할 수 있다.

        * <strong>단점</strong>

            * 1. 코드 복잡성 증가: 추가적인 클래스 및 인터페이스가 필요하기 때문에 복잡성이 증가한다.

            * 3. 어려움: 전략 패턴을 구현하기 위해서 적절한 분석과 설계가 요구되기 때문에 어려움이 있다.

    </details>