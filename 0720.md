# 7월 20일 TIL

* ### 알고리즘
    * [Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/description/)
    <details>
      <summary><strong>코드 - 누적합</strong></summary>

     ```java
        import java.util.*;
        /**
            x = n * k라 할 때,
            (A, B) 누적합
            (B - A) = x

            (B - A) % k = x % k
            (B - A) % k = 0
            B % k = A % k

            를 이용해서 나머지가 같은 구간의 길이가 2이상인 곳을 찾는다
        */

        class Solution {
            public boolean checkSubarraySum(int[] nums, int k) {
                if(nums.length == 1)return false;

                Map<Integer, Integer> count = new HashMap<>();
                count.put(0,-1);
                int total = 0;

                for(int i=0 ; i<nums.length; i++){
                    total = (total + nums[i]) % k;

                    if(count.containsKey(total)){
                        // 만약 앞에서 같은 나머지가 있고 길이가 2이상이면 true 반환
                        if(i - count.get(total) >= 2)return true;
                    }else{
                        // 처음 나온 나머지의 인덱스 저장
                        count.put(total, i);
                    }
                }
                return false;
            }
        }
    ```
    </details>


 * ### 멘토링 질문
    <details>
    <summary><strong>메모리 단편화</strong></summary>

    #### 메모리 단편화란
    메모리 단편화라는 것은 데이터 파일이나 실행 파일같은 컴퓨터 파일을 하드디스크나 RAM같은 컴퓨터 저장소에 다른 부분에 저장을 하는 조각으로 나누는 과정이다. 조각이 된 파일들은 불연속적인 블록들에 저장이 된다.

    #### 그렇다면 메모리 단편화는 왜 발생할까?
    메모리 단편화는 파일들이 저장소에 연속적인 블록에 저장하기에는 너무 크거나, 여유가 있는 블록에 파일을 넣어두기에 충분하지 않을 때 발생한다.

    #### 단편화의 종류
    **내부 단편화**와 **외부 단편화**가 있다.<br/>

    1. **내부 단편화**
    내부단편화는 메모리 블록안에서 사용하지 않는 공간이 있을 때 발생한다. 예를 들어서, 만약 64kb으로 할당된 메모리 블록에 40kb 크기의 파일이 저장된다면 24kb의 내부 단편화가 생긴다. 즉, 24kb 크기의 공간이 낭비되는 것이다.
    <br/>

    2. **외부 단편화**
    외부 단편화는 하드디스크나 SSD같은 저장 매체에 작은 여유 공간이 여러개 있을 때 발생한다. 시스템에서 파일들을 자주 생성하거나 삭제되면 여러개의 작은 블락들이 남겨지면서 생기는 경우에 발생한다. 기존의 40kb가 할당되어 있던 메모리 블록에 20kb가 들어간다면 20kb라는 공간이 생긴다. 이런식으로 메모리 공간의 중간마다 빈 공간이 생기게 된다.


    #### 단편화 해결 방법

    * **가상 메모리**: 실제 메모리 크기와 관계 없이 메모리를 사용할 수 있도록 가상 메모리 주소를 뜻한다. 프로세스의 일부분만 메모리에 로드하고 나머지는 보조 기억 장치(가상 메모리 공간)에 로드한다. **MMU**(가상 주소를 실제 메모리 주소로 변환해주는 장치)를 통해 논리 주소, 물리 주소를 나누어 사용한다.

    <br/>

    1. **페이지 기법**
    가상메모리를 같은 크기의 블록으로 나눈 것을 페이지(page)라고 하고 RAM을 페이지와 같은 크기의 블록으로 나눈 것을 프레임(frame)이라고 한다. 페이징 기법은 사용하지 않는 프레임을 페이지로 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 방법을 말한다. 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장된다. 매핑을 위해서 페이징 테이블을 이용하는데, 여기에는 메인 메모리에 적재되어 있는 페이지 번호와 해당 페이지가 위치한 메인 메모리의 시작 주소가 있다.

    <br/>
    
    <a href=https://velog.io/@gang_shik/%ED%8E%98%EC%9D%B4%EC%A7%95Paging%EA%B3%BC-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98Segmentation> 매핑 테이블 그림</a>
    <img width=80% height=500vh src=https://github.com/user-attachments/assets/a4f84804-8805-4b07-9a41-c25d996e387f>
    </img>
    <br/>

    MMU에선 가장 주소를 이용해 실제 데이터가 담겨 있는 주소로 변환을 해주는데 논리주소는 <page, offset>과 같은 형태를 이용한다. TBL라는 MMU 내부에 페이지 테이블만 이용하는 버퍼를 통해 캐시 구조를 이용한다.

    > ##### 장점: 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화가 생기지 않는다.
    > ##### 단점: 내부 단편화 문제가 발생할 수 있다.

    <br/>


    2. **세그멘테이션 기법**
    가상 메모리를 서로 다른 크기로 논리적 단위로 분할한 하는 기법으로, 프로세스를 물리적 단위인 페이지가 아닌 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식이다. 세그먼트는 의미가 같지 않는 논리적 내용을 기준으로 프로그램을 분할하기 때문에 크기가 같지 않다. 분할 방식을 제외하고는 페이징 기번과 동일하기 때문에 매핑 테이블의 동작 방식도 같다. 단, 논리 주소의 앞 비트들은 페이징 번호가 아닌 세그먼트번호가 된다. <segment, offset> 형태로 구성되고 세그먼트 번호를 통해 세그먼트의 시작 물리 주소와 세그먼트의 길이를 파악할 수 있다.



    <br/>
    
    <a href=#> 매핑 테이블 그림</a>
    <img width=80% height=500vh src=>
    </img>
    <br/>

    MMU에선 가장 주소를 이용해 실제 데이터가 담겨 있는 주소로 변환을 해주는데 논리주소는 <page, offset>과 같은 형태를 이용한다. TBL라는 MMU 내부에 페이지 테이블만 이용하는 버퍼를 통해 캐시 구조를 이용한다.

    > ##### 장점: 내부 단편화 문제가 해소되며, 보호와 공유 기능을 수행할 수 있다. 프로그램의 중요한 
    > ##### 단점: 내부 단편화 문제가 발생할 수 있다.
    


    </details>